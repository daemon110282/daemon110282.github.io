# Распил монолита

- [Распил монолита](#распил-монолита)
  - [Зачем](#зачем)
  - [Приоритеты для распила](#приоритеты-для-распила)
  - [Извлечение сервисов](#извлечение-сервисов)
    - [Паттерны](#паттерны)
    - [Рефакторинг кода](#рефакторинг-кода)
    - [Рефакторинг БД](#рефакторинг-бд)
    - [Рефакторинг интеграций](#рефакторинг-интеграций)
      - [Рефакторинг синхронного взаимодействия](#рефакторинг-синхронного-взаимодействия)
      - [Рефакторинг асинхронного взаимодействия (шины сообщений)](#рефакторинг-асинхронного-взаимодействия-шины-сообщений)
    - [Рефакторинг авторизации](#рефакторинг-авторизации)
  - [Модульный монолит](#модульный-монолит)

Паттерны распила [монолита](../style/monolit.md) на [MSA](../style/msa.md)

## Зачем

- __Ускорение разработки__. Если согласно плану какая-то часть вашего приложения будет активно развиваться на протяжении следующего года, разработку можно ускорить путем извлечения ее в сервис.
- Решение проблем с __производительностью, масштабируемостью и надежностью__. Если определенная часть вашего приложения ненадежна или имеет проблемы с производительностью или масштабируемостью, будет полезно преобразовать ее в сервис.
- Возможность извлечь какие-то другие сервисы. Иногда из-за __зависимостей между модулями__ извлечение одного сервиса упрощает извлечение другого.

Альтернатива - модульный монолит.

## Приоритеты для распила

Что [вынести в первую очередь](http://agilemindset.ru/от-монолита-к-микросервисам-в-разумно/) в сервис\модуль, а что можно оставить?

- Бизнес-критичность
- Интенсивность изменений
- Инновационность
- Объем транзакций (обращений)  
- Уровень зависимостей
- Утилизация ресурсов
- Сложность сервиса  

Имеет смысл извлечь сервис, __функции, которого постоянно эволюционируют и имеют критическое значение с точки зрения бизнеса__. Если извлечение не приносит существенной выгоды, не стоит тратить на него время.

## Извлечение сервисов

ФБ - функциональный блок - бизнес-возможность - поддомен [DDD](ddd.md).

- нужно решить, как разбить __доменную модель монолита на отдельные модели (ФБ)__, одна из которых будет принадлежать сервису.
- Для вынесения функциональности придется разорвать зависимости
  - объектные ссылки, и, возможно, __разделить существующие классы__
  - модифицировать __[структуру базы данных](#рефакторинг-бд)__
- при извлечении сервиса вы разделяете то, что прежде было ACID-транзакциями. Вы должны внимательно __следить за сохранением согласованности__, для этого иногда применяются [повествования Event Sourcing](event.sourcing.md).

### Паттерны

![Схема](http://www.plantuml.com/plantuml/proxy?cache=no&src=https://raw.githubusercontent.com/daemon110282/daemon110282.github.io/daemon110282-patch-1/arch/pattern/monolit2msa.puml)

- __Feature Toogle__

### Рефакторинг кода

- Слои приложения разделить: UI-BLL-DAL
- Паттерн __"Фикус-удавка" (strangler fig app)__ - параллельная функциональность с [маршрутизацией запросов](#рефакторинг-интеграций)
	- Выявить зависимости между ФБ
	- Выносить нижестоящие ФБ первыми без зависимостей нижестоящих
	- Состояние (БД) вынести и возможно потребуется обратно его обновлять
	- Возможность переключения-отката: монолит-сервис
    	- Ограничение: если изменения функционала происходят в сервисе, откат затрудняется, требуется синхронизировать и монолит. В идеале __фриз измненений__.
- Паттерн __"Ветвление по абстракции" (branch by abstraction)__
	- Монолит переключается на абстракцию
	- Имплементация абстракции AS-IS
	- Имплементация абстракции адаптера TO-BE к новому сервису
	- Переключение на TO-BE имплементацию
		- Feature Toogle
		- Тестирование, Rollback если __фриз измненений__
	- Удаление AS-IS иплементации

### Рефакторинг БД

Вопросы:

- Выделен DAL, есть адаптер до БД, исп-ся паттерн Репозиторий?
- Анализ в коде зависимости View, SP, trigger от таблиц 

__методики рефакторинга__ схемы базы данных:

- Паттерн __«разделение таблицы» (split table)__, который разбивает одну таблицу на две или больше
	- 1м этапом в той же БД, тесты
	- 2м - в новой БД сервиса
- Разделить операции чтения\изменения данных (CQRS)
	- Операции изменения в 1ю очередь в новый сервис
		- Адаптер в монолите к АПИ нового сервиса
		- Репликация данных полей на чтение в монолите (триггеры? между БД одной СУБД работают?)
	- Операции чтения во 2ю
		- Снижает изменения интеграций со смежными ИС потребителями данных на чтение
- Синонимы в БД?
- Паттерн __"Совместное использование БД"__ несколькими сервисами
  - минусы: нет сокрытия и изоляция данных, размыто понимание какой сервис какими данными владеет
  - подходит для:
    - статических справочных данных для чтения
    - БД для интеграция нескольких внешних ИС потребителей
- Паттерн __"Представления (проекции view) БД"__ для внешних ИС потребителей
- минусы: единое ядро СУБД между ИС как правило необходимо, иначе проблемы совместимости, скорости (MSSQL2PgSQL и тп)
- Паттерн __"Сервис обертки над БД" (database wrapping service)__
  - подходит где сложно разобрать быстро модель БД и замораживается развитие БД
    - контроль, что скрыто в модели от потребителей
  - минусы: "повязка" временная для постепенного рефакторинга модели БД
- Паттерн __"Интерфейс БД как служба"__
  - Основная БД отображается на отдельную БД на чтение для внешних ИС потребителей
    - механизм отобажения: онлайн CDC (Devezium и тп), пакетный ETL
  - Изменения в основной БД происходят через API
  - минусы: доп расходы на отдельную БД и механизм отображения
    - альтернатива: реплика полная БД, но сокрытия нет и ИС потребители сами следят за изменениями модели БД
  - Отличие от Паттерна "Представления БД", что отдельная БД может быть __на другом тех стеке__
  - подходит для отчетности

### Рефакторинг интеграций

Вопросы:

- Выделен интеграционный слой, есть адаптер до API\RMQ, исп-ся паттерн Репозиторий?

#### Рефакторинг синхронного взаимодействия

- Маршрутизация на API GW
- Трансформация форматов, протоколов, типов, технологий интеграций (SOAP2gRPC, REST2gROC, SOAP2REST и тп)
	- на API GW
    	- минусы: "умный" канал
	- на уровне ИС источника API поддержка нескольких форматов
		- минусы: в каждой ИС Потребителе потребуется доработка

#### Рефакторинг асинхронного взаимодействия (шины сообщений)

- Паттерн __Маршрутизация основанная на содержимом сообщений__
  - минусы: канал - шина сообщений становится "умной"
- Паттерн __Селективное потребление__
  - минусы: доработка монолита для игнорирования сообщений

### Рефакторинг авторизации

- Cookie Based авторизация на основе сессий расширяется параметром - __JWT access токен__ с доступом пользователя, который на уровне API GW передается в Header Authorization: Bearer {{token}}
	- Как генерировать access token?
	- Как валидировать access token, если нет Сервиса Авторизации?
	- Роли на уровне сервиса? Централизован ролевой доступ в Сервисе Авторизаций?
	- 2й этап - Сервис Авторизации

## Модульный монолит

  - Изоляция модулей
  - Не обязательно обмен __доменными событиями__ между модулями (на следующей фазе)
  - Отдельные схемы БД
  - Сохраняем БД транзакции и ссылки между таблицами
