# Распил монолита

- [Распил монолита](#распил-монолита)
  - [Зачем](#зачем)
  - [Организационные изменения](#организационные-изменения)
  - [Приоритеты для распила](#приоритеты-для-распила)
  - [Извлечение сервисов](#извлечение-сервисов)
    - [Паттерны](#паттерны)
    - [Рефакторинг кода](#рефакторинг-кода)
    - [Рефакторинг БД](#рефакторинг-бд)
      - [Синхронизация данных](#синхронизация-данных)
      - [Миграция данных](#миграция-данных)
    - [Рефакторинг интеграций](#рефакторинг-интеграций)
      - [Рефакторинг синхронного взаимодействия](#рефакторинг-синхронного-взаимодействия)
      - [Рефакторинг асинхронного взаимодействия (шины сообщений)](#рефакторинг-асинхронного-взаимодействия-шины-сообщений)
    - [Рефакторинг авторизации](#рефакторинг-авторизации)

Паттерны распила [монолита](../style/monolit.md) на [MSA](../style/msa.md)

## Зачем

- __Ускорение разработки__. Если согласно плану какая-то часть вашего приложения будет активно развиваться на протяжении следующего года, разработку можно ускорить путем извлечения ее в сервис.
- Решение проблем с __производительностью, масштабируемостью и надежностью__. Если определенная часть вашего приложения ненадежна или имеет проблемы с производительностью или масштабируемостью, будет полезно преобразовать ее в сервис.
- Возможность извлечь какие-то другие сервисы. Иногда из-за __зависимостей между модулями__ извлечение одного сервиса упрощает извлечение другого.

Альтернатива - [модульный монолит](../style/monolit.modul.md).

## Организационные изменения

- Сервисы лучше писать [не монолитчику](https://habr.com/ru/articles/508856/) - он и так довел монолит до текущего состояния
- С недоверием относитесь к переиспользованию функционала. Наоборот, любой функционал должен дублироваться.

## Приоритеты для распила

Что [вынести в первую очередь](http://agilemindset.ru/от-монолита-к-микросервисам-в-разумно/) в сервис\модуль, а что можно оставить?

- Метрики
	- Бизнес-критичность
	- Интенсивность изменений
	- Инновационность
	- Объем транзакций (обращений)  
	- Уровень зависимостей
	- Утилизация ресурсов
	- Сложность сервиса  
- Имеет смысл извлечь сервис, __функции, которого постоянно эволюционируют и имеют критическое значение с точки зрения бизнеса__. Если извлечение не приносит существенной выгоды, не стоит тратить на него время.
	- Возможна высокая трудоемкость распила всего монолита и делать __только новые сервисы вокруг монолита__, а [монолит не распиливать](https://habr.com/ru/companies/vk/articles/519354/).

## Извлечение сервисов

ФБ - функциональный блок - бизнес-возможность - поддомен [DDD](ddd.md).

- нужно решить, как разбить __доменную модель монолита на отдельные модели (ФБ)__, одна из которых будет принадлежать сервису
- Для вынесения функциональности придется разорвать зависимости
  - объектные ссылки, и, возможно, __разделить существующие классы__
  - модифицировать __[структуру базы данных](#рефакторинг-бд)__
- при извлечении сервиса вы разделяете то, что прежде было ACID-транзакциями. Вы должны внимательно __следить за сохранением согласованности__, для этого иногда применяются
  - [повествования Event Sourcing](event.sourcing.md)
  - [Рефакторинг БД](#рефакторинг-бд)
- Чтобы ограниченные контексты отделять друг от друга и начать процесс выделения микросервисов из монолитного решения, мы использовали такой подход, как [создание внутри приложения внешних API](https://habr.com/ru/companies/raiffeisenbank/articles/458404/)

Что извлекать первым: код или БД?

- если можно изменять монолит, БД
- иначе - код

### Паттерны

- [Feature Toogle](feature.toggle.md)

### Рефакторинг кода

![Схема](http://www.plantuml.com/plantuml/proxy?cache=no&src=https://raw.githubusercontent.com/daemon110282/daemon110282.github.io/daemon110282-patch-1/arch/pattern/monolit2msa.puml)

- Слои приложения разделить: UI-BLL-DAL
- Выявить зависимости между ФБ
  - Выносить Вышестоящие ФБ первыми без зависимостей от Нижестоящих (внешние вызовы). Паттерн __"Фикус-удавка" (strangler fig app)__ - параллельная функциональность с [маршрутизацией запросов](#рефакторинг-интеграций)
  	- Состояние (БД) вынести и возможно потребуется обратно его обновлять
  	- Возможность переключения-отката: монолит-сервис
      	- Ограничение: если изменения функционала происходят в сервисе, откат затрудняется, требуется синхронизировать и монолит. В идеале __фриз измненений__.
  - Иначе (не рекомендуется) выносить Нижестоящие ФБ с зависимостями от Вышестоящих (внутренние вызовы). Паттерн __"Ветвление по абстракции" (branch by abstraction)__
  	- Монолит переключается на абстракцию
  	- Имплементация абстракции AS-IS
  	- Имплементация абстракции адаптера TO-BE к новому сервису
  	- Переключение на TO-BE имплементацию
  		- Тестирование, Rollback если __фриз измненений__
  	- Удаление AS-IS иплементации

### Рефакторинг БД

Вопросы:

- Выделен __DAL__, есть адаптер до БД, исп-ся паттерн Репозиторий?
- Анализ в коде __зависимости__ View, SP, trigger от таблиц
  - проблема: использование __шаблона shared database__. Данные брались из таблиц через view, через интеграцию загружались в другие ИС. В результате мы не могли выносить таблицы в отдельную схему, потому что они активно использовались.

![Схема](http://www.plantuml.com/plantuml/proxy?cache=no&src=https://raw.githubusercontent.com/daemon110282/daemon110282.github.io/daemon110282-patch-1/arch/pattern/monolit2msa.db.puml)

__методики рефакторинга__ схемы базы данных:

- отделение существующих таблиц, переносятся как есть в НС
- отделение таблиц с рефакторингом
  - Паттерн __«разделение таблицы» (split table)__, который разбивает одну таблицу на две или больше
  	- 1м этапом в той же БД, тесты
  	- 2м - в новой БД сервиса
- __Разделить операции чтения\изменения__ данных (CQRS)
	- Операции __изменения в 1ю очередь__ [в новый сервис](https://habr.com/ru/companies/raiffeisenbank/articles/458404/)
		- Адаптер в монолите к АПИ нового сервиса
		- [Синхронизация данных](#синхронизация-данных) полей на чтение в монолите
	- Операции __чтения во 2ю__ очередь
		- Снижает изменения интеграций со смежными ИС потребителями данных на чтение
		- Необходима [__миграция__ текущих данных](migration.md) в новый сервис
- __Синонимы в БД__?
- Паттерн __"Совместное использование БД"__ несколькими сервисами
  - минусы: нет сокрытия и изоляция данных, размыто понимание какой сервис какими данными владеет
  - подходит для:
    - статических справочных данных для чтения
    - БД для интеграция нескольких внешних ИС потребителей
- Паттерн __"Представления (проекции view) БД"__ для внешних ИС потребителей
- минусы: единое ядро СУБД между ИС как правило необходимо, иначе проблемы совместимости, скорости (MSSQL2PgSQL и тп)
- Паттерн __"Сервис обертки над БД" (database wrapping service)__
  - подходит где сложно разобрать быстро модель БД, поэтому замораживается развитие БД, все изменения через Сервис
    - контроль, что скрыто в модели от потребителей
  - минусы: "повязка" временная для постепенного рефакторинга модели БД
- Паттерн __"Интерфейс БД как служба"__
  - Основная БД отображается на __отдельную БД на чтение для внешних ИС__ потребителей
    - механизм отобажения:
      - онлайн [CDC](../../technology/cdc.md) (Devezium и тп)
      - пакетный ETL
  - Изменения в основной БД происходят через API
  - подходит для: отчетности
  - минусы: доп расходы на отдельную БД и механизм отображения
    - альтернатива: реплика полная БД, но сокрытия нет и ИС потребители сами следят за изменениями модели БД
  - Отличие от Паттерна "Представления БД" - отдельная БД может быть __на другом тех стеке__

#### Синхронизация данных

- триггеры? между БД одной СУБД работают?
- Писать в обе БД (2 истины), чтение только из новой БД
  - Механизмы сверки данных необходимы.

#### Миграция данных

[Миграция текущих данных](migration.md) в новый сервис

- __Импорт заранее__ в НС
  - Полная - большой взрыв, ИС источник выключается
  - Частичная - параллельно обе ИС работают
- __Импорт по запросу__ Агрегата - в НС нет данных Агрегата, идет проверка в монолит на наличие и импорт из монолита сначала, затем изменения Агрегата в НС

### Рефакторинг интеграций

Вопросы:

- Выделен интеграционный слой, есть адаптер до API\RMQ, исп-ся паттерн Репозиторий?

#### Рефакторинг синхронного взаимодействия

- Маршрутизация на API GW
- Трансформация форматов, протоколов, типов, технологий интеграций (SOAP2gRPC, REST2gROC, SOAP2REST и тп)
	- на API GW
    	- минусы: "умный" канал
	- на уровне ИС источника API поддержка нескольких форматов
		- минусы: в каждой ИС Потребителе потребуется доработка

#### Рефакторинг асинхронного взаимодействия (шины сообщений)

- Паттерн __Маршрутизация основанная на содержимом сообщений__
  - минусы: канал - шина сообщений становится "умной"
- Паттерн __Селективное потребление__
  - минусы: доработка монолита для игнорирования сообщений

### Рефакторинг авторизации

- Cookie Based авторизация на основе сессий расширяется параметром - __JWT access токен__ с доступом пользователя, который на уровне API GW передается в Header Authorization: Bearer {{token}}
	- Как генерировать access token?
	- Как валидировать access token, если нет Сервиса Авторизации?
	- Роли на уровне сервиса? Централизован ролевой доступ в Сервисе Авторизаций?
	- 2й этап - Сервис Авторизации

