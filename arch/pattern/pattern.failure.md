# Паттерны обработки сбоев

- [Паттерны обработки сбоев](#паттерны-обработки-сбоев)
	- [Логика повторения (Retry Logic, Retry Policy)](#логика-повторения-retry-logic-retry-policy)
	- [Rate limit](#rate-limit)
	- [Fail fast](#fail-fast)
	- [Каскадные сбои](#каскадные-сбои)
	- [Автоматы замыкания (Circuit Breakers)](#автоматы-замыкания-circuit-breakers)
	- [Links](#links)

- сбои разделяют:
  - [временные](https://docs.microsoft.com/ru-ru/azure/architecture/best-practices/transient-faults)
  - долгосрочные
  - окончательные
- Проверка работоспособности (Health-check) и балансировка нагрузки

TODO https://docs.google.com/document/d/1uVwJSFrDnKlJCQoK81P2UmpGzuPHoRQ7L9u8dFuB3yQ/edit?usp=sharing

## Логика повторения (Retry Logic, Retry Policy)

- Поскольку повтор инициируется клиентом (браузером, другим микросервисом и так далее), который не знает, была ли операция сбойной до или после обработки запроса, приложение должно уметь обрабатывать **[идемпотентность](idempotent.md)**. Например, когда вы повторяете операцию покупки, то вы не должны дублировать взимание средств с покупателя. Вам поможет использования уникального ключа идемпотентности для каждой транзакции.

## Rate limit

- вид ограничителя скорости называется ограничитель одновременных запросов (concurrent request limiter). Он может быть полезен, когда у вас есть «дорогие» конечные точки, которые не рекомендуется вызывать больше определённого количества раз, если вы хотите обслуживать трафик.
- Чтобы у вас всегда хватало ресурсов для обслуживания критически важных транзакций, используйте **fleet usage load shedder**.
  - Он удерживает часть ресурсов для высокоприоритетных запросов и не позволяет низкоприоритетным транзакциям их использовать.
  - Load shedder принимает свои решения на основе общего состояния системы, а не размера одиночного пользовательского запроса.

## Fail fast

Выбросить ошибку как можно раньше подходы:

* Лимит на объемы любых запрашиваемых клиентом данных
* Обязательный таймаут на все удаленные операции
  * Для баз данных и на клиенте и на сервере, т.к прерванный запрос может продолжать выполнение
* Ограничение частоты обращений к серверу, а после превышения - 429 error code
* Ограничение количества открываемых входящих / исходящих соединений
* Ограничение размера задействованных пулов потоков под каждый тип операций
* Валидация аргументов запроса к сервису на стороне клиента (запрос все равно будет отвергнут, но мы сохраним время на удаленных вызов и пропускную способность сети)

Применение парадигмы «быстрого сбоя» **fail fast** в микросервисах посредством таймаутов является **антипаттерном**, которого следует избегать. Вместо таймаутов можете применять шаблон **circuit-breaker**, который зависит от статистики успешных/сбойных операций.

## Каскадные сбои

- В микросервисной архитектуре нужно подготовить свои сервисы **сбоить быстро и раздельно**.
- Быстрый сбой компонентов нужен потому, что мы не хотим ждать, пока закончатся таймауты сломанных инстансов. Ничто так не раздражает, как зависший запрос и не отвечающий на ваши действия интерфейс. Это не только потерянные ресурсы, но и испорченный пользовательский опыт. 
- Сервисы вызывают друг друга по цепочке, поэтому нужно уделять особое внимание предотвращению повисания операций, не допуская накопления задержек.

## Автоматы замыкания (Circuit Breakers)

- Автомат замыкания открывается, когда в течение короткого времени несколько раз возникает ошибка определённого типа. Открытый автомат предотвращает передачу запросов
- не все ошибки должны инициировать автомат замыкания. Например, вы наверняка захотите пропустить ошибки на стороне клиента вроде запросов с кодами 4хх, но при этом отреагировать на серверные сбои с кодами 5хх.

## Links

* https://habr.com/ru/company/nix/blog/342058/
* https://docs.microsoft.com/ru-ru/dotnet/architecture/microservices/implement-resilient-applications/partial-failure-strategies
* https://russianblogs.com/article/4093102387/
