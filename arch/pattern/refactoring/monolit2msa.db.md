# Рефакторинг БД

- [Рефакторинг БД](#рефакторинг-бд)
  - [Зачем](#зачем)
    - [Паттерны](#паттерны)
      - [Паттерны БД](#паттерны-бд)

Паттерны распила [монолита](../../style/monolit.md) на [MSA](../../style/msa.md)

## Зачем

Часть [рефакторинга монолита](monolit2msa.md).

### Паттерны

Вопросы:

- Выделен __DAL__, есть адаптер до БД, исп-ся паттерн Репозиторий?
- Анализ в коде __зависимости__ View, SP, trigger от таблиц
  - проблема: использование __шаблона shared database__. Данные брались из таблиц через view, через интеграцию загружались в другие ИС. В результате мы не могли выносить таблицы в отдельную схему, потому что они активно использовались.

#### Паттерны БД

![Схема](../../../out/arch/pattern/refactoring/monolit2msa.db/(@id=db).svg)

__Паттерны рефакторинга__ схемы базы данных:

- __Разделить данные__ по признаку Сущности, например: Новый клиенты в НС, повторные в монолите
  - плюысы: не требуется реализации [миграции данных](./migration.md)
  - минусы: синхронизация в монолит потребуется, для возможности отката НС при итеративном распиле
- отделение __существующих таблиц__
  - переносятся __как есть__ в НС (антипаттерн?)
  - отделение таблиц с рефакторингом
    - Паттерн __«разделение таблицы» (split table)__, который разбивает одну таблицу на две или больше
    	- 1м этапом в той же БД, тесты
    	- 2м - в новой БД сервиса
- __Разделить операции чтения\изменения__ данных (CQRS)
	- Операции __изменения в 1ю очередь__ [в новый сервис](https://habr.com/ru/companies/raiffeisenbank/articles/458404/)
		- Адаптер в монолите к АПИ нового сервиса
		- [Синхронизация данных](../integration/sync.data.md) полей на чтение в монолите
	- Операции __чтения во 2ю__ очередь
		- Снижает изменения интеграций со смежными ИС потребителями данных на чтение
		- Необходима [__миграция__ текущих данных](./migration.md) в новый сервис
		- TODO __Синонимы в БД__?
- Паттерн __"Совместное использование БД"__ несколькими сервисами
  - минусы: нет сокрытия и изоляция данных, размыто понимание какой сервис какими данными владеет
  - подходит для:
    - __статических справочных данных__ для чтения
    - БД для интеграция нескольких внешних ИС потребителей
- Паттерн __"Представления (проекции view) БД"__ для внешних ИС потребителей
  - минусы: единое ядро СУБД между ИС как правило необходимо, иначе проблемы совместимости, скорости (MSSQL2PgSQL и тп)
- Паттерн __"Сервис обертки над БД" (database wrapping service)__
  - подходит где сложно разобрать быстро модель БД, поэтому замораживается развитие БД, все изменения через Сервис
    - контроль, что скрыто в модели от потребителей
  - минусы: "повязка" временная для постепенного рефакторинга модели БД
- Паттерн __"Интерфейс БД как служба"__
  - Основная БД отображается на __отдельную БД на чтение для внешних ИС__ потребителей
    - механизм отображения:
      - онлайн [CDC](../../system.class/cdc.md) (Devezium и тп)
      - пакетный [ETL](../integration/ETL.md)
      - [CDC vs ETL](../integration/sync.data.md)
  - Изменения в основной БД происходят через API
  - подходит для: отчетности
  - минусы: доп расходы на отдельную БД и механизм отображения
    - альтернатива: [реплика полная БД](../integration/sync.data.md), но сокрытия нет и ИС потребители сами следят за изменениями модели БД
  - Отличие от Паттерна "Представления БД" - отдельная БД может быть __на другом тех стеке__
- Писать в обе БД (__2 источника истины__), чтение только из новой БД
  - __Механизмы сверки данных необходимы__
  - Устранение двойной записи - [шаблон Outbox вместе с Debezium](https://debezium.io/blog/2019/02/19/reliable-microservices-data-exchange-with-the-outbox-pattern/), можно сделать так, что сервисы будут выполнять обе задачи – обновлять данные и уведомлять другие сервисы – безопасно и согласованно.
