# Microservice architecture

- [Microservice architecture](#microservice-architecture)
  - [Зачем](#зачем)
  - [Плюсы и минусы](#плюсы-и-минусы)
  - [Паттерны](#паттерны)
  - [Технологии](#технологии)
  - [Reference Architecture](#reference-architecture)
  - [Чек-лист по сервису](#чек-лист-по-сервису)
  - [todo](#todo)

## Зачем

- [TODO](https://photos.app.goo.gl/fx9KTNZDV8vS6GE78)
- Сокращение time2market
- Независимость
- Небольшие команды
- Разделение
- Одна функция
- Корректно описанные интерфейсы
- Весь жизненный цикл
- Минимизация коммуникаций
- Уменьшение масштаба изменений

## Плюсы и минусы

[Критерии](../arch.criteria.md)

| + | - |
| - | - |
| Слабая связность | Сложность |
| Проще тестировать | Сложная инфраструктура |
| Быстро деплоить и откатывать | Инфраструктурный код |
| Целостность, слабая связность | Сложность распределенных транзакций |
| Масштабируемость ||
| Модульность ||
| Кроссплатформенность ||
| Независимый тех стек ||
| Независимая эволюция ||

__Не подходит__ для:

- Старт-апов MVP
- «Ядерных» систем бизнеса, требующих ACID транзакций

Проблемы:

- Если границы по-настоящему хорошо не определены, случится так, что — даже в случае теоретической возможности изолированного деплоя сервисов — всплывут взаимные __зависимости между сервисами__, из-за которых придётся деплоить наборы сервисов как группу (__архитектурный квант__).
  - независимо масштабируемые сервисы вряд ли помогут, потому что остаётся влияние производительности зависимостей.

В сравнении с [монолитом](../style/monolit.md) плюсы:

- Независимое развертывание и обновление
- При необходимости отдельные микросервисы могут быть развернуты или масштабированы независимо
- Независимый релизный цикл
- Разные языки программирования и БД в разных сервисах
  - Интересный стек технологий для разработчиков
- Повторное использование
- Микросервисы это изоляция по функционалу и по данным (каждый микросервис должен хранить данные в своей базе данных иначе считается что это не настоящие микросервисы).
- Гибкое перераспределение нагрузки на всех уровнях
- Высокая скорость доставки
- Выделение и изолирование функциональности
- Канареечные релизы
- Небольшие команды
- Возможность перепридумать решение с нуля
- Высокая отказоустойчивость
- Актуальные технологии индустрии, появилось большое число качественных opensource платформ
- Слабая связанность
- Можно быстро переписать код
- Легко заменять модули
- Устойчивость
- Улучшение доступности за счет изоляции сбоев в границах отдельного сервиса
- Изоляция и слабая связанность ведут к возможностям более гибкой эволюции в границах модуля
- Поддержка множества платформ и языков
- Быстрое тестирование
- Быстрый деплой
- Автономный деплой
- Использование трассировки запросов между сервисами
- Быстрота решения инцидентов
- Быстрее локальная разработка - не нужно все разворачивать
- Возможность динамического распределения нагрузки
- Независимая разработка
- Проще рефакторить, меньше тех.долга - проще переписать один независимый сервис
- Свой архитектурный подход для каждого сервиса (DDD, CRUD)

Минусы:

- Транзакции сложно, в идеале без них
- Согласованность данных сложно обеспечить
- наивно полагать, что микросервисы полностью избавят вашу ИТ-среду от сложности.
- увеличении сложности управления, разработки и поддержки по причине их децентрализации. 
- Более того, не каждое приложение в корпоративной среде подходит для архитектуры микросервисов.
- Сложность управления и мониторинга транзакций
- Сложность сопровождения
- Сложность проектирования
- Сложный вход, так как толстый технологический стек
- Дублирование данных (но не доменных сущностей)
- Проблемы с целостностью межсервисных операций
- Сквозное логирование бизнес-процесса
- Дорогие специалисты
- Сложность отладки
- Сложность в поиске специалистов и обучении команд
- Отсутствует качественная "теория" по моделированию распределенных асинхронных процессов - BPMN и прочие UML не эффективны
- Сложность диагностики
- Сложность проектирования и разработки
- У каждой успешной компании в MSA свой "опыт" и "заплатки" трудно обобщать
- Сложно всем этим зоопарком управлять
- Сложность управлением памятью
- Сложность системы в целом
- Дольше разрабатывать
- Сложнее определить требования к ресурсам
- Стоимость владения может оказаться выше
- Высокие затраты на входе
- Производительность массовых операций из-за межсетевых вызовов
- Поиск ошибок среди всего множества сервисов
- Сложность использования общих библиотеки
- Необходимость наличия культуры в организации
- Сложность декомпозиции
- Наличие множества БД и их поддержки
- Необходимость в большом количестве инфраструктурных ресурсов
- Требуется организация взаимосвязи между микросервисами
- Больше оборудования чем в монолите
- Без должной автоматизации деплой сложнее

## Паттерны

- three main topologies stand out as the most common and popular:
  - the API REST-based topology
  - application REST-based topology
  - the centralized messaging topology
- Декомпозиции на сервисы
  - [Decompose by business capability Context](https://microservices.io/patterns/decomposition/decompose-by-business-capability.html)
  - [Decompose by subdomain Context](https://microservices.io/patterns/decomposition/decompose-by-subdomain.html)
- [Обработка сбоев](../pattern/pattern.failure.md)
- Аутентификация
  - Leave the data where it is, and have services ask for it directly. Use a gateway to attach the data to all requests, so it's available everywhere. Centralize authorization data into one place, and move [all decisionmaking to that place](https://www.osohq.com/post/microservices-authorization-patterns).
- [Microservice Design Pattern](https://apolomodov.medium.com/%D0%BE%D0%B1%D0%B7%D0%BE%D1%80-%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8-microservice-patterns-and-best-practices-dce7785b9c45)
  - Aggregator
  - Proxy
  - Chained
  - Branch (Aggregator + Chained в связке)
- TODO
  - [Паттерны управления данными](https://mcs.mail.ru/blog/26-osnovnyh-patternov-mikroservisnoj-razrabotki)
  - [26 основных паттернов микросервисной разработки](https://mcs.mail.ru/blog/26-osnovnyh-patternov-mikroservisnoj-razrabotki)


### Принципы к проектированию сервисов

- У сервиса должна быть [конкретная ответственность](https://habr.com/ru/companies/vk/articles/519354/). Если для его полноценного функционирования нужен ещё сервис, то это ошибка проектирования, их нужно либо объединять, либо пересматривать архитектуру.
- Критично смотрим на любые синхронные обращения. Для сервисов в одном направлении это допустимо, но для общения между сервисами разных направлений — нет
- Share nothing. Мы не ходим в БД сервисов в обход них самих. Все запросы только через API.
- Specification First. Сначала описываем и утверждаем протоколы.

## Технологии

- Service Mesh

## Reference Architecture

- [eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers)
- [About
Microservices on .Net platforms which used Asp.Net Web API, Docker, RabbitMQ, MassTransit, Grpc, Ocelot API Gateway, MongoDB, Redis, PostgreSQL, SqlServer, Dapper, Entity Framework Core, CQRS and Clean Architecture implementation.](https://github.com/aspnetrun/run-aspnetcore-microservices)
- ДБО (СДО)
  - [BSS](https://plusworld.ru/lr/bss-microservice/)

## Чек-лист по сервису

- Логи пишутся в консоль/stdout в формате json
- Конфигурация в ЕNV-переменных
- Миграции для БД
- Swagger
- Идемпотетность. Идемпотентным называют такой метод API, повторный вызов которого не меняет состояние. НО: результат идемпотентного вызова может меняться.
- Кэш
- Отсутствие состояния - Stateless состояние не внутри сервиса: а в бд, redis. масштабировать непосредственно сервера приложений. сделать так, чтобы как можно меньше было хранения состояний в самом приложении

## todo

Mock, test: https://microcks.io/documentation/getting-started/

Паттерн повествование, коммуникаций

Кейсы недоступности, ошибок
Sla: rps, таймаут время ответа/отклика
Чек-лист по сервису
Умный HealthCheck

Graceful shutdown
Горизонтальное масштабирование
Идемпотентность
Повторы неизбежны
Делайте методы идемпотентными
Регистрируйте уже принятые ID событий
Игнорируйте более давние события
