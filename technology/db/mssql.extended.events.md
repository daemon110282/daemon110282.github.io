# Extended Events

- [Extended Events](#extended-events)
	- [Зачем](#зачем)
	- [Плюсы и минусы](#плюсы-и-минусы)
	- [Паттерны](#паттерны)
		- [CPU](#cpu)
		- [Long Query поиск тяжелых запросов](#long-query-поиск-тяжелых-запросов)
		- [Locks](#locks)
			- [Lock Escalation](#lock-escalation)
		- [Errors](#errors)
		- [TempDB](#tempdb)
		- [Разбор логов](#разбор-логов)

## Зачем

Содержат информацию о запросах с параметрами за определенный период с затратами на запрос по CPU, IOPS, длительности, кол-ву записей, пользователе, logical\physical reads в БД.

Microsoft SQL Server:

- 2008: первая версия ХЕ без GUI
- 2012: профайлер признан устаревшим
- 2014: хорошее рабочее решение
- 2019: фантастический инструмент, включающий более 1300 событий

## Плюсы и минусы

- Значительно меньшее влияние на производительность при включенном сборе данных, причем имеются расширенные настройки, с помощью которых на это можно влиять.
- Настройки сбора данных (события, фильтры и др.) можно менять на активных сессиях, прямо во время сбора данных.
- Доступен хэш запросов, чтобы идентифицировать одинаковые тексты запросов.
- Можно настроить различные способы хранения логов, причем одновременно в нескольких вариантах.
- Встроенные инструменты в SQL Server Managment Studio и инструкции TSQL для работы с ними.

## Паттерны

### CPU

- событий по CPU достаточно использовать два события
  - __RPC:Completed__ - вызов процедур через обращение к sp_executesql
  - __SQL:BatchCompleted__ - выполнение пакета запросов
  - фильтр по полю времени выполнения события (поле “duration”) в микросекундах, которые выполняются более 5 секунд (5 000 000 микросекунд)

### Long Query поиск тяжелых запросов

- используется __объем логических чтений__, т.е. тех, которые были выполнены из __оперативной памяти__. Это важно, т.к. SQL Server кэширует страницы, полученные с диска в буферный кэш, то есть в оперативную память. Именно поэтому SQL Server такой прожорливый в части использования RAM
- фильтр на поле с размером прочитанных данных, те __logical reads__
  - зависит от конкретной системы и размера базы. Обычно использую значение фильтра от 10000 до 50000 прочитанных страниц (то есть от ~80 МБ до ~400 МБ, т.к. 1 страница = 8 КБ)

### Locks

- собирать информацию об __ожиданиях на блокировках__ с помощью механизма __отчетов по заблокированным процессам__. Он включается в свойствах сервера и выполняет сбор статистики с заданной периодичностью (обычно 5 секунд достаточно)
- Deadlock

#### Lock Escalation

CREATE EVENT SESSION [TMP_LockEscalation] ON SERVER ADD EVENT sqlserver.lock_escalation(
ACTION(sqlserver.context_info, sqlserver.database_name, sqlserver.is_system, sqlserver.query_hash, sqlserver.session_id, sqlserver.sql_text, sqlserver.username))
ADD TARGET package.event_file(SET filename=N'TMP_LockEscalation') WITH (MAX_MEMORY=4096 KB,
EVENT_RETENTION_MODE=ALLOW_SINGLE_EVENT_LOSS, MAX_DISPATCH_LATENCY=30 SECONDS, MAX_EVENT_SIZE=0 KB, MEMORY_PARTITION_MODE=NONE, TRACK_CAUSALITY=OFF, STARTUP_STATE=ON)

### Errors

- отслеживать любые ошибки, происходящие на уровне СУБД. Для этого воспользуемся скриптом для сбора всех ошибок с помощью события __SQL:ErrorReported__

### TempDB

- TempDB spiils - не хватка памяти при оценке плана выполнения запросов и использование tempdb для кэширования запросов - снижение Latency

### Разбор логов

- копируем файлы XEL с собранными данными на сервер логов или локальный компьютер, т.к. выполнять анализ данных на рабочем сервере дело рисковое, ведь он может “съесть” значительную часть ресурсов.
- запустим SQL Server Managment Studio и перейдем в “Файл -> Открыть -> Объединить файлы расширенных событий….”.
  - После добавляем в список все файлы, которые хотим обработать
  - запускаем мастер выгрузки событий в таблицу базы данных